LCGdefaults1 = [97, 2, 3, 0, 100]
# Default settings for LCGgenerator (function below)
def LCGgenerator(m, a, c, seed, length):
  oldval = seed
  outlist = []
  for i in range(length):
    #generate a list of random numbers equal to the number you entered for length (typically the length of the message to be encrypted)
    newval = (a * oldval + c)%m
    outlist.append(newval)
    oldval = newval
  return(outlist)
# take a string and split it into a list with the values being numbered (1-x instead of 0-x)
def dictalign(list):
  outdict = {}
  list = list.split()
  for i in range(len(list)):
    e = i+1
    outdict[e] = list[i]
  return(outdict)
alphabet = dictalign('a b c d e f g h i j k l m n o p q r s t u v w x y z')
numbers = dictalign('1 2 3 4 5 6 7 8 9 0')
symbols = dictalign(r'- _ = + < , > . ? / : ; " \' { [ } ] \ | ` ~ ! @ # $ % ^ & * ( )')
symbols[len(symbols)+1] = ' '

# Invert keys and values of the dictionaries and save to a seperate variable
numbersvals = numbers.values()
numberkeys = numbers.keys()
symbolvals = symbols.values()
symbolkeys = symbols.keys()
alphabetletters = alphabet.values()
alphabetnumbers = alphabet.keys()
inversealphabet = dict(zip(alphabetletters, alphabetnumbers))
inversenumbers = dict(zip(numbersvals, numberkeys))
inversesymbols = dict(zip(symbolvals, symbolkeys))

# WIP
def shiftbylist(character, list, shift, cypher):
  pass

# Main function
def cypher(message, alphabet, shift, cypher):
  # Parameters: Message (message to be encrypted), alphabet (dictionary containing symbols used in the cypher), shift (list of random numbers equal in length to the message, generated by LCGgenerator), cypher (True encrypts the message, False decrypts it)
  alphabetletters = alphabet.values()
  alphabetnumbers = alphabet.keys()
  inversealphabet = dict(zip(alphabetletters, 
  alphabetnumbers))
  # Invert dictionary keys and values
  message = message.lower()
  for i in range(len(message)):
    newcharacter = message[i]
    if message[i] in alphabet.values():
      # Ensures the character to be encyphered is in the reference alphabet dictionary
      characterindex = inversealphabet[message[i]]
      if cypher == True:
        newcharacter = alphabet[((characterindex+shift[i])%len(alphabet))]
        try:
          # Error catcher sets the character to the last one in the dictionary in the event of the input being zero (modulo sets values of 26 to zero)
          newcharacter = alphabet[((characterindex+shift[i])%len(alphabet))]
        except:
          newcharacter = alphabet[(len(alphabet))]
      else:
        # Read above comment ^
        try:
          newcharacter = alphabet[(characterindex-shift[i])%len(alphabet)]
        except:
          newcharacter = alphabet[(len(alphabet) - 1)]
          # Adds the encyphered character to the string to return
    message = message[:i] + newcharacter + message[i+1:]
  return(message)

seed = input("What would you like the seed to be? ")
message = input("What message would you like to encrypt/decrypt? ")
rnglist = LCGgenerator(97, 2, 3, int(seed), len(message))
#encryptdecrypt = '515125'
encryptdecrypt = input("Would you like to encrypt or decrypt this data? Type 1 or 2 ")
if encryptdecrypt == '1':
  message = cypher(message, alphabet, rnglist, True)
  message = cypher(message, numbers, rnglist, True)
  message = cypher(message, symbols, rnglist, True)
else:
  message = cypher(message, alphabet, rnglist, False)
  message = cypher(message, numbers, rnglist, False)
  message = cypher(message, symbols, rnglist, False)
print(message)